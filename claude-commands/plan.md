# PLAN

## 1. SELECT AND SCOPE TASK
- Read `BACKLOG.md` and identify the top item as the task description string.
- Evaluate if the task represents a single atomic unit of functionality:
  - A single, well-defined responsibility
  - One logical change that can be understood in isolation
  - Independently testable
  - Completes a discrete, meaningful step toward a larger goal
  - Can be reviewed thoroughly in a single sitting

## 2. TASK DECOMPOSITION (IF NEEDED)
- If the task exceeds an atomic unit of functionality:
  1. Break the task into multiple atomic units (as many as needed)
  2. Sequence them in dependency order
  3. Update `BACKLOG.md` to:
     - Remove the original task
     - Add the first atomic unit at the top (current task)
     - Add remaining atomic units as separate backlog items below
  4. Document relationships and dependencies between units
  5. Ensure each atomic unit delivers testable value on its own

## 3. PREPARE TASK FILE
- Create a file named `TASK-PROMPT.md`.
- Write the following into `TASK-PROMPT.md`:
    ```markdown
    # Task Planning Request

    ## Task Description
    [Insert properly scoped task description from Steps 1-2]

    ## Request
    Analyze the task description within the project context. Propose potential implementation plans. For each plan:
    1.  Outline the main approach and key steps.
    2.  Discuss potential pros and cons (consider maintainability, performance, alignment with existing code).
    3.  **Evaluate alignment with standards:** How well does this approach align with:
        - Core design principles in `CORE_PRINCIPLES.md` (especially simplicity and modularity)
        - Architectural patterns in `ARCHITECTURE_GUIDELINES.md` (particularly separation of concerns)
        - Coding practices in `CODING_STANDARDS.md` (leveraging language features appropriately)
        - Testability principles in `TESTING_STRATEGY.md` (can it be tested with simple, reliable tests, minimizing mocks?)
        - Documentation patterns in `DOCUMENTATION_APPROACH.md` (design decisions clearly expressible)
    4.  Highlight any potential risks or challenges.

    Recommend the best overall plan, explicitly justifying the choice based on requirements, project standards, and **prioritizing long-term maintainability and testability.**
    ```

## 4. GENERATE PLAN WITH THINKTANK
- **Goal:** Use `thinktank` to generate potential implementation plans from multiple LLMs based on the properly scoped task description and project context.
- **Actions:**
    - **Initial Attempt (Relevant Context):** 
        1. Find the top ten most relevant files for context
        2. Run the following command:
        ```bash
        thinktank run --group faves TASK-PROMPT.md [top-ten-relevant-files]
        ```
    - **Handle Errors:** If `thinktank` fails:
        - Report the specific error message.
        - Write the error to a persistent log file.
        - Analyze the error. Attempt to fix and retry **once** if feasible.
        - If unresolvable, report "Thinktank CLI invocation failed. See error above. Manual assistance required." and **stop**.
    - **Identify Output Directory:** If the command completes successfully, identify the output directory path created by `thinktank`. Report "Thinktank CLI invocation successful. Responses saved in <output-directory-path>."

## 5. SYNTHESIZE PLAN
- **Goal:** Consolidate the plans generated by different LLMs into a single, coherent `PLAN.MD`, prioritizing testability and ensuring proper scope.
- **Actions:**
    - Navigate to the identified `thinktank` output directory.
    - Read all the individual model response files (`*.md`).
    - **Synthesize:** ***Think hard*** and synthesize the proposed steps, approaches, considerations (especially testability evaluations), and potential challenges from the various LLM responses into a single, comprehensive, and actionable plan.
    - **Verify Scope:** Ensure the synthesized plan represents a single atomic unit of functionality that can be implemented in one pull request.
    - **Prioritize:** When resolving contradictions or choosing between approaches, give significant weight to the plan that best aligns with our standards hierarchy:
      1. First, prioritize simplicity and clarity (`CORE_PRINCIPLES.md`)
      2. Second, ensure strong separation of concerns (`ARCHITECTURE_GUIDELINES.md`)
      3. Third, maximize testability with minimal mocking (`TESTING_STRATEGY.md`)
      4. Fourth, follow idiomatic coding patterns (`CODING_STANDARDS.md`)
      5. Fifth, support clear documentation of design decisions (`DOCUMENTATION_APPROACH.md`)
      
      Accept additional complexity only when it demonstrably serves these principles. Document this reasoning thoroughly.
    - Save this synthesized plan to `PLAN.MD`.
    - (Optional Cleanup): Remove the temporary `TASK-PROMPT.md` file.

## 6. CHECKOUT BRANCH
- Switch to a new git branch for implementing the work described in the synthesized `PLAN.MD`.
