#!/bin/bash
# tt-review-complexity - Code complexity and simplification review using shared library

# Source the shared library
source "$(dirname "$0")/tt-common.sh"

# Function to detect default branch
get_default_branch() {
    local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

    if [[ -n "$default_branch" ]]; then
        echo "$default_branch"
        return
    fi

    if git show-ref --verify --quiet refs/heads/main; then
        if git show-ref --verify --quiet refs/heads/master; then
            echo "master"
        else
            echo "main"
        fi
    elif git show-ref --verify --quiet refs/heads/master; then
        echo "master"
    else
        echo "master"
    fi
}

tt_main() {
    # Configure this script
    tt_set_config \
        --template-name "review-complexity" \
        --output-file "CODE_REVIEW_COMPLEXITY.md" \
        --description "Analyzes code complexity and identifies simplification opportunities"

    # Parse arguments for base branch
    local base_branch=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                tt_show_usage
                exit 0
                ;;
            --dry-run)
                TT_DRY_RUN=true
                shift
                ;;
            *)
                base_branch="$1"
                shift
                ;;
        esac
    done
    
    # Use default branch if none specified
    if [[ -z "$base_branch" ]]; then
        base_branch=$(get_default_branch)
    fi

    # Get current branch name
    local current_branch
    current_branch=$(git branch --show-current)

    if [[ -z "$current_branch" ]]; then
        echo "Error: Not on a branch" >&2
        exit 1
    fi

    # Get list of changed files
    local changed_files
    changed_files=$(git diff --name-only "$base_branch" 2>/dev/null | while read -r file; do [[ -f "$file" ]] && echo "$file"; done || true)

    if [[ -z "$changed_files" ]]; then
        echo "No changes detected between $current_branch and $base_branch"
        exit 0
    fi

    local file_count
    file_count=$(echo "$changed_files" | wc -l | tr -d ' ')

    echo "Generating complexity analysis for $file_count files..."

    # Get the diff content
    local diff_content
    diff_content=$(git diff "$base_branch")

    # Set the template content
    tt_set_template << 'EOF'
# Code Complexity and Simplification Review

Analyze changed code for unnecessary complexity and identify opportunities for simplification.

**FOCUS**: Review changed lines (+ in diff) for over-engineering, unnecessary abstractions, and opportunities to simplify.

## Complexity Indicators to Identify

### 1. Over-Engineering
- **Premature Abstraction**: Interfaces/classes with single implementation
- **Unnecessary Patterns**: Design patterns where simple code suffices
- **Gold Plating**: Features beyond current requirements
- **YAGNI Violations**: "You Aren't Gonna Need It" - future-proofing

### 2. Code Complexity
- **Deep Nesting**: More than 3 levels of indentation
- **Long Methods**: Functions doing too many things
- **Complex Conditionals**: Hard-to-follow boolean logic
- **Parameter Overload**: Functions with too many parameters

### 3. Abstraction Issues
- **Leaky Abstractions**: Implementation details bleeding through
- **Wrong Level**: Abstractions at inappropriate layers
- **Indirection Overload**: Too many layers between intent and implementation
- **Framework Obsession**: Using frameworks where vanilla code works

### 4. Simplification Opportunities
- **Duplicate Logic**: Similar code that could be unified
- **Dead Code**: Unused functions, variables, imports
- **Verbose Patterns**: Code that could be more concise
- **Configuration Complexity**: Over-configurable systems

## Output Format
```
# Complexity Analysis

## ðŸ”´ HIGH COMPLEXITY ISSUES
### [Issue Title] - HIGH
- **Location**: file_path:line_numbers
- **Complexity Type**: [over-engineering/deep-nesting/abstraction]
- **Current**: [What makes it complex]
- **Simplified**: [Concrete simpler approach]
- **Benefit**: [Readability/maintenance improvement]
- **Example**:
  ```language
  // Current complex code
  ```
  ```language
  // Simplified version
  ```

## ðŸŸ¡ MODERATE COMPLEXITY
### [Issue Title] - MEDIUM
- **Location**: file_path:line_numbers
- **Issue**: [What could be simpler]
- **Suggestion**: [How to simplify]
- **Trade-off**: [Any downsides to consider]

## ðŸŸ¢ SIMPLIFICATION OPPORTUNITIES
### [Opportunity Title] - LOW
- **Location**: file_path:line_numbers
- **Current**: [Existing approach]
- **Alternative**: [Simpler option]
- **Effort**: [Easy/Medium/Hard to refactor]

## ðŸ“Š METRICS
- Cyclomatic Complexity: [Notable functions >10]
- Nesting Depth: [Files with >3 levels]
- Abstraction Layers: [Excessive indirection]
- LOC Reduction Potential: [Estimated % reducible]

## ðŸŽ¯ REFACTORING PRIORITIES
1. **Quick Wins**: [Easy simplifications with high impact]
2. **Strategic Simplifications**: [Larger refactors worth doing]
3. **Technical Debt**: [Complex areas needing future attention]

## âœ… SUMMARY
- High Complexity Issues: X
- Simplification Opportunities: Y
- Estimated Refactoring Effort: [hours/days]
- Code Clarity Improvement: [HIGH|MEDIUM|LOW]
```

Remember: Favor simple, explicit code over clever abstractions. The best code is code that doesn't exist.
EOF

    # Set the context with PR details and diff
    tt_set_context "## PR Details
Branch: $current_branch
Files Changed: $file_count

## Diff
\`\`\`diff
$diff_content
\`\`\`"

    # Set the target files (changed files)
    tt_set_target_files "$(echo "$changed_files" | tr '\n' ' ')"
}

# Main execution
tt_main "$@"
tt_run