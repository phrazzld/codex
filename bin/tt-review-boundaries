#!/bin/bash
# tt-review-boundaries - Module boundaries and dependency review using shared library

# Source the shared library
source "$(dirname "$0")/tt-common.sh"

tt_main() {
    # Configure this script
    tt_set_config \
        --template-name "review-boundaries" \
        --output-file "CODE_REVIEW_BOUNDARIES.md" \
        --description "Validates module separation, boundaries, and dependency clarity"

    # Use the shared function for git diff setup
    tt_setup_diff_review "$@"

    # Set the template content
    tt_set_template << 'EOF'
# Module Boundaries and Dependencies Review

Analyze code for proper module separation, clear boundaries, and explicit dependencies based on leyline philosophy.

**FOCUS**: Review changes for boundary violations, improper dependencies, and coupling issues.

## Boundary Analysis Framework

### 1. Module Cohesion
- **Single Responsibility**: Each module has one clear purpose
- **High Cohesion**: Related functionality stays together
- **Clear Purpose**: Module's role is obvious from structure
- **Self-Contained**: Minimal external dependencies

### 2. Dependency Direction
- **Inward Dependencies**: Domain never depends on infrastructure
- **Layer Respect**: Dependencies flow in one direction
- **No Circular Dependencies**: A→B→C never leads back to A
- **Stable Dependencies**: Depend on abstractions, not concretions

### 3. Interface Design
- **Clear Contracts**: Interfaces define explicit boundaries
- **Minimal Surface**: Small, focused public APIs
- **Stable Interfaces**: Changes don't cascade
- **Domain Language**: Interfaces use business terms

### 4. Coupling Analysis
- **Loose Coupling**: Modules can change independently
- **No Feature Envy**: Code uses its own data
- **Law of Demeter**: Don't reach through objects
- **Dependency Injection**: External dependencies are explicit

### 5. Architectural Boundaries
- **Core Domain**: Pure business logic, no frameworks
- **Application Layer**: Use cases and orchestration
- **Infrastructure**: External systems and frameworks
- **Clear Adapters**: Translation at boundaries

## Output Format
```
# Boundary and Dependency Analysis

## 🔴 CRITICAL BOUNDARY VIOLATIONS
### [Violation Type] - CRITICAL
- **Location**: file_path:line_numbers
- **Violation**: [Layer breach|Circular dependency|etc]
- **Current Structure**: [How boundaries are crossed]
- **Impact**: [Coupling, rigidity, cascade changes]
- **Fix**: [How to restore proper boundaries]
- **Diagram**:
  ```
  Current (Violation):
  Domain → Infrastructure → Database
     ↑________________________|
  
  Fixed:
  Domain ← Application → Infrastructure → Database
  ```

## 🟡 DEPENDENCY ISSUES
### [Issue Type] - MEDIUM
- **Location**: file_path:line_numbers
- **Problem**: [Hidden dependency|Wrong direction|etc]
- **Current Dependency**: A depends on B
- **Should Be**: B depends on A (or use interface)
- **Refactoring Steps**: [How to fix]

## 🔍 COUPLING CONCERNS
### High Coupling Detected
- **Between**: ModuleA ↔ ModuleB
- **Coupling Type**: [Data|Control|Content|Common|etc]
- **Evidence**: [Multiple touchpoints, shared state, etc]
- **Decoupling Strategy**: [Interface extraction, event-driven, etc]

### Feature Envy
- **Location**: file_path:line_numbers
- **Envious Code**: [Code more interested in other module]
- **Target Module**: [Where code logically belongs]
- **Move Strategy**: [How to relocate functionality]

## 📊 BOUNDARY METRICS
### Module Analysis
- Modules with Clear Boundaries: X/Y
- Boundary Violations: Z instances
- Average Module Cohesion: [High|Medium|Low]

### Dependency Health
- Circular Dependencies: X cycles found
- Wrong-Direction Dependencies: Y instances
- Hidden Dependencies: Z detected
- Dependency Depth: Max N levels

### Coupling Measurements
- Afferent Coupling (Ca): [Incoming dependencies]
- Efferent Coupling (Ce): [Outgoing dependencies]
- Instability (I = Ce/(Ca+Ce)): [0-1 score]
- Abstractness: [Ratio of interfaces to implementations]

## 🎯 ARCHITECTURAL RECOMMENDATIONS
### Immediate Fixes
1. **Break These Cycles**: [Circular dependencies to resolve]
2. **Reverse These Dependencies**: [Wrong direction flows]
3. **Extract These Interfaces**: [Reduce coupling points]

### Boundary Improvements
1. **Strengthen These Boundaries**: [Weak separation points]
2. **Create These Adapters**: [Missing translation layers]
3. **Isolate These Concerns**: [Mixed responsibilities]

### Long-term Architecture
1. **Module Reorganization**: [Better cohesion grouping]
2. **Layer Clarification**: [Clearer architectural layers]
3. **Interface Evolution**: [More stable contracts]

## ✨ GOOD BOUNDARY EXAMPLES
### [Well-Designed Module]
- **Location**: file_path or module
- **Boundary Strength**: [What makes it well-separated]
- **Pattern**: [Reusable approach]

## ⚠️ BOUNDARY RISKS
### Future Coupling Risks
- **Potential Issue**: [Emerging coupling pattern]
- **Warning Signs**: [What to watch for]
- **Prevention**: [How to maintain boundaries]

## ✅ SUMMARY
- Boundary Health Score: [X/10]
- Critical Violations: X
- Dependency Issues: Y
- Coupling Score: [Low|Medium|High]
- Architecture Stability: [Stable|At Risk|Degrading]

**Recommendation**: [REFACTOR boundaries | MONITOR coupling | MAINTAIN separation]
```

Remember: Good fences make good neighbors. Clear boundaries enable independent evolution.
EOF
}

# Main execution
tt_main "$@"
tt_run