#!/bin/bash
# tt-groom - Backlog grooming using shared library

# Source the shared library
source "$(dirname "$0")/tt-common.sh"

# Custom output handling for grooming (replaces default tt_handle_output)
tt_groom_handle_output() {
    # Find the most recent output directory created by thinktank
    local latest_output_dir
    latest_output_dir=$(find . -maxdepth 1 -name "thinktank-*" -type d -newermt '1 minute ago' 2>/dev/null | sort -r | head -1)
    
    if [[ -n "$latest_output_dir" ]]; then
        # Look for the main output file in the directory
        local output_file
        output_file=$(find "$latest_output_dir" -name "*.md" -type f | head -1)
        
        if [[ -n "$output_file" ]]; then
            # Save current backlog as backup
            cp BACKLOG.md BACKLOG.md.backup
            echo "Saved current backlog to BACKLOG.md.backup"
            
            # Copy output to groomed file
            cp "$output_file" BACKLOG.md.groomed
            echo "Created BACKLOG.md.groomed from thinktank output"
            
            # Show preview of groomed backlog
            echo ""
            echo "Preview of groomed backlog:"
            echo "=========================="
            head -30 BACKLOG.md.groomed
            echo ""
            echo "[...truncated for preview]"
            echo ""
            
            # Prompt for replacing backlog
            read -p "Replace BACKLOG.md with groomed version? (y/N): " -n 1 -r
            echo ""
            
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                mv BACKLOG.md.groomed BACKLOG.md
                echo "BACKLOG.md has been updated with groomed version"
                echo "Original backlog saved as BACKLOG.md.backup"
            else
                echo "Groomed backlog saved as BACKLOG.md.groomed"
                echo "Original BACKLOG.md unchanged"
            fi
            
            echo ""
            echo "Backlog grooming complete!"
            return 0
        else
            echo "Warning: Could not find output file in $latest_output_dir" >&2
            return 1
        fi
    else
        echo "Warning: Could not find thinktank output directory" >&2
        echo "Make sure thinktank executed successfully" >&2
        return 1
    fi
}

tt_main() {
    # Configure this script
    tt_set_config \
        --template-name "groom" \
        --output-file "BACKLOG.md.groomed" \
        --description "Organizes, expands, and prioritizes the project backlog" \
        --requires-input-file "BACKLOG.md"

    # Read the current backlog content
    local backlog_content
    backlog_content=$(cat BACKLOG.md)

    # Set the template content
    tt_set_template << 'EOF'
# Backlog Grooming: Comprehensive Organization & Expansion

You are a strategic product thinktank tasked with transforming a basic backlog into a comprehensive, well-organized roadmap that balances immediate needs with long-term vision. Your assignment is to analyze the current backlog and codebase architecture to produce a thoughtfully structured, prioritized, and expanded BACKLOG.md.

Keep the program's purpose in mind throughout this process. Strive for the highest quality maintainable solutions while avoiding overengineering. Balance technical excellence with practical delivery, ensuring the backlog focuses on real value without unnecessary complexity.

## 1. Analyze Current Backlog

Review the existing BACKLOG.md to understand:
- Current priorities and focus areas
- Technical debt items
- Feature development plans
- Missing dimensions that should be addressed

## 2. Study Codebase Architecture

Examine all provided glance.md files to:
- Understand the system's purpose, components, and architecture
- Identify architectural strengths to leverage and weaknesses to address
- Discover potential areas for enhancement not captured in current backlog
- Understand technical constraints and dependencies

Examine all provided development philosophy files and leyline documents to understand the ideal structure and architecture of the system.

## 3. Craft a Multi-Dimensional Backlog

Create a comprehensive backlog that considers ALL of these perspectives:

**Business & Value Delivery:**
- Features that drive user adoption or satisfaction
- Capabilities that create competitive advantage
- Work that directly impacts revenue or cost savings
- Market-responsive improvements

**Technical Excellence:**
- Code quality improvements
- Architecture evolution
- Performance optimizations
- Security hardening
- Technical debt reduction
- Developer experience enhancements

**Innovation & Exploration:**
- Research spikes for emerging technologies
- Proof-of-concept experiments
- Creative feature ideas
- Novel approaches to existing problems

**Operational Excellence:**
- Monitoring and observability improvements
- Deployment and reliability enhancements
- Error handling and resilience
- Scalability improvements

## 4. Apply Meaningful Organization

Structure the backlog with:

1. **Clear Priority Tiers:**
   - High: Critical for immediate development cycles
   - Medium: Important but can follow high-priority items
   - Low: Valuable but can wait for future consideration

2. **Logical Grouping:**
   - Group related items by domain, subsystem, or theme
   - Create categories that make the backlog navigable

3. **Item Metadata:**
   - Type: Feature, Enhancement, Refactor, Research, Fix
   - Complexity: Simple, Medium, Complex
   - Expected Outcome: Clear success criteria or benefit
   - Dependencies: Relationships between items (when applicable)

## 5. Format Requirements

Present the backlog in Markdown with consistent formatting:

```markdown
# BACKLOG

## High Priority

### [Category/Group Name]

- **[Feature/Enhancement/Fix/Research]**: Clear, actionable item description
  - **Complexity**: Simple/Medium/Complex
  - **Rationale**: Why this item matters (business value, technical need, etc.)
  - **Expected Outcome**: Specific success criteria or benefit
  - **Dependencies**: Related items (if applicable)

### [Another Category]
...

## Medium Priority
...

## Low Priority
...

## Future Considerations
...
```

## 6. Synthesis Guidelines

- **Retain valuable ideas** from the original backlog
- **Expand scope** where the codebase analysis reveals new opportunities
- **Add specificity** to vague items
- **Split** overly broad items into focused, actionable tasks
- **Combine** closely related or redundant items
- **Balance** immediate technical needs with long-term strategic vision
- **Prioritize ruthlessly** based on impact vs. effort
- **Consider interdependencies** between items when sequencing
- **Clean up** completed items and items that reference them as dependencies

## Output Requirements

- Provide ONLY the complete, formatted BACKLOG.md contentâ€”no other commentary
- Ensure every item has clear rationale tied to business value, technical excellence, or strategic advancement
- Maintain a healthy balance across all dimensions (business value, technical excellence, innovation, operations)
- Items must be specific enough to be actionable but not prescriptive about implementation details
EOF

    # Set the context with backlog content
    tt_set_context "## Backlog Grooming Context

### Current Backlog
$backlog_content

### Grooming Goals
- Prioritize items based on business value and technical dependencies
- Identify missing tasks that should be added
- Remove or modify outdated tasks
- Ensure all tasks are clear, atomic, and actionable"
}

# Custom main execution that overrides output handling
tt_main "$@"

# Validate configuration
if [[ -z "$TT_CONFIG_TEMPLATE_NAME" || -z "$TT_CONFIG_OUTPUT_FILE" || -z "$TT_CONFIG_DESCRIPTION" ]]; then
    echo "Error: tt_set_config must be called with required parameters" >&2
    exit 1
fi

if [[ -z "$TT_TEMPLATE_CONTENT" ]]; then
    echo "Error: tt_set_template must be called" >&2
    exit 1
fi

# Parse arguments
local remaining_args
remaining_args=$(tt_parse_args "$@")

# Check requirements
tt_check_requirements

# Create instruction file
local instruction_file
instruction_file=$(tt_create_temp_files)

# Find leyline files
local leyline_files
leyline_files=$(tt_find_leyline_files)

# Use target files if set, otherwise use remaining args
local target_files
if [[ -n "$TT_TARGET_FILES" ]]; then
    target_files="$TT_TARGET_FILES"
else
    target_files="$remaining_args"
fi

# Execute thinktank
if ! tt_execute_thinktank "$instruction_file" "$target_files" "$leyline_files"; then
    exit 1
fi

# Handle output with custom logic (skip for dry run)
if [[ "$TT_DRY_RUN" != true ]]; then
    if ! tt_groom_handle_output; then
        exit 1
    fi
fi