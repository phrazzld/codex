#!/bin/bash
# tt-review-conversation - Generate questions for code review discussions using shared library

# Source the shared library
source "$(dirname "$0")/tt-common.sh"

# Function to detect default branch
get_default_branch() {
    local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

    if [[ -n "$default_branch" ]]; then
        echo "$default_branch"
        return
    fi

    if git show-ref --verify --quiet refs/heads/main; then
        if git show-ref --verify --quiet refs/heads/master; then
            echo "master"
        else
            echo "main"
        fi
    elif git show-ref --verify --quiet refs/heads/master; then
        echo "master"
    else
        echo "master"
    fi
}

tt_main() {
    # Configure this script
    tt_set_config \
        --template-name "review-conversation" \
        --output-file "CODE_REVIEW_CONVERSATION.md" \
        --description "Generates thoughtful questions to facilitate code review discussions"

    # Parse arguments for base branch
    local base_branch=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                tt_show_usage
                exit 0
                ;;
            --dry-run)
                TT_DRY_RUN=true
                shift
                ;;
            *)
                base_branch="$1"
                shift
                ;;
        esac
    done
    
    # Use default branch if none specified
    if [[ -z "$base_branch" ]]; then
        base_branch=$(get_default_branch)
    fi

    # Get current branch name
    local current_branch
    current_branch=$(git branch --show-current)

    if [[ -z "$current_branch" ]]; then
        echo "Error: Not on a branch" >&2
        exit 1
    fi

    # Get list of changed files
    local changed_files
    changed_files=$(git diff --name-only "$base_branch" 2>/dev/null | while read -r file; do [[ -f "$file" ]] && echo "$file"; done || true)

    if [[ -z "$changed_files" ]]; then
        echo "No changes detected between $current_branch and $base_branch"
        exit 0
    fi

    local file_count
    file_count=$(echo "$changed_files" | wc -l | tr -d ' ')

    echo "Generating conversation starters for $file_count files..."

    # Get the diff content
    local diff_content
    diff_content=$(git diff "$base_branch")

    # Set the template content
    tt_set_template << 'EOF'
# Code Review Conversation Generator

Generate thoughtful questions that promote learning, uncover hidden assumptions, and improve code quality through dialogue.

**GOAL**: Create questions that lead to insights, not just criticisms. Foster collaborative improvement and shared understanding.

## Question Categories

### 1. Design Decisions
- Why this approach over alternatives?
- What trade-offs were considered?
- How does this fit the larger architecture?
- What constraints influenced this design?

### 2. Future Evolution
- How will this handle future requirements?
- What happens when scale increases 10x?
- Where might this pattern break down?
- What's the migration path if we need to change?

### 3. Hidden Assumptions
- What domain knowledge is assumed?
- What invariants must hold true?
- What external dependencies exist?
- What error conditions are possible?

### 4. Learning Opportunities
- What pattern is being introduced here?
- How does this improve on previous approaches?
- What can the team learn from this?
- Should this become a standard pattern?

### 5. Edge Cases & Robustness
- What happens in failure scenarios?
- How does this handle concurrent access?
- What about empty/null/extreme inputs?
- Are there timing/ordering dependencies?

### 6. Alternative Perspectives
- How would a new developer understand this?
- What would operations team need to know?
- How does this affect other teams/services?
- What's the user's perspective on this change?

## Output Format
```
# Code Review Discussion Guide

## ðŸ¤” Key Design Questions
### About [Component/Pattern/Decision]
**Context**: [Brief description of what the code does]
**Question**: [Thoughtful question about the approach]
**Why This Matters**: [Impact on maintainability/performance/etc]
**Discussion Points**:
- [Specific aspect to explore]
- [Alternative to consider]
- [Trade-off to evaluate]

## ðŸ”® Future-Proofing Questions
### Regarding [Scalability/Flexibility/Evolution]
**Current Assumption**: [What the code assumes today]
**Question**: [How will this handle future scenarios?]
**Scenarios to Consider**:
- [Specific future change]
- [Growth pattern]
- [New requirement type]

## ðŸ’¡ Learning & Pattern Questions
### Pattern: [Identified Pattern or Approach]
**Question**: [Is this a pattern we want to standardize?]
**Benefits**:
- [Why this pattern helps]
- [Problems it solves]
**Considerations**:
- [When to use it]
- [When to avoid it]
**Team Learning**: [What everyone can learn from this]

## ðŸŽ¯ Clarification Questions
### About [Unclear/Complex Section]
**Question**: [What needs clarification]
**Current Understanding**: [What seems to be happening]
**Seeking**: [Specific information needed]
**Documentation Opportunity**: [What should be documented]

## ðŸ›¡ï¸ Robustness Questions
### Error Handling in [Component]
**Question**: [What happens when X fails?]
**Current Behavior**: [What the code does now]
**Edge Cases to Discuss**:
- [Specific failure mode]
- [Unusual input]
- [Resource constraint]

## ðŸ¤ Cross-Team Impact Questions
### For [Other Team/Service/Component]
**Question**: [How does this affect X team?]
**Touchpoints**: [Where systems interact]
**Communication Needed**: [What to coordinate]

## ðŸŽ“ Knowledge Sharing Prompts
### Domain Knowledge
**Question**: [Can you explain the business rule behind X?]
**Current Implementation**: [How it's coded]
**Business Context**: [Why it matters]
**Documentation**: [Where this should be captured]

## ðŸ’­ "What If" Scenarios
### Scenario: [Hypothetical situation]
**Question**: [How would the code handle this?]
**Current Design**: [Current capability]
**Implications**: [What would need to change]

## ðŸ”„ Refactoring Discussion
### Opportunity: [Potential improvement]
**Question**: [Should we refactor X while we're here?]
**Current State**: [What exists]
**Improved State**: [What it could be]
**Effort vs. Benefit**: [Trade-off analysis]

## ðŸ“š Best Practices Discussion
### Practice: [Relevant best practice]
**Question**: [How can we better apply X principle?]
**Current Alignment**: [How well we follow it]
**Improvement Path**: [Steps to better adherence]

## ðŸŽ¯ Action Items from Discussion
Based on these questions, consider:
1. **Documentation**: What needs to be written down?
2. **Patterns**: What should become team standards?
3. **Refactoring**: What improvements to schedule?
4. **Learning**: What knowledge to share with team?
5. **Process**: What development process to adjust?

## ðŸ’¬ Conversation Starters
Pick 3-5 questions from above that are most relevant to this PR and use them to start a meaningful discussion. The goal is mutual learning and code improvement, not just approval.

**Remember**: Great code reviews are conversations, not inspections.
```

Focus on questions that:
- Promote learning over criticism
- Uncover hidden complexity
- Explore alternatives constructively
- Share knowledge across the team
- Improve future development
EOF

    # Set the context with PR details and diff
    tt_set_context "## PR Details
Branch: $current_branch
Files Changed: $file_count

## Diff
\`\`\`diff
$diff_content
\`\`\`"

    # Set the target files (changed files)
    tt_set_target_files "$(echo "$changed_files" | tr '\n' ' ')"
}

# Main execution
tt_main "$@"
tt_run